#! @PERL@
#! /usr/bin/perl

##--------------------------------------------------------------------##
##--- Massif's results printer                         ms_print.in ---##
##--------------------------------------------------------------------##

#  This file is part of Massif, a Valgrind tool for profiling memory
#  usage of programs.
#
#  Copyright (C) 2007-2007 Nicholas Nethercote
#     njn@valgrind.org
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License as
#  published by the Free Software Foundation; either version 2 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
#  02111-1307, USA.
#
#  The GNU General Public License is contained in the file COPYING.

use warnings;
use strict;

# XXX:need to put threshold in the stats at the top of the output

#----------------------------------------------------------------------------
# Global variables, main data structures
#----------------------------------------------------------------------------

# Generic description string.
my $desc = "";

# Command line of profiled program.
my $cmd;

# Threshold dictating what percentage an entry must represent for us to
# bother showing it.
my $threshold = 1.0;

# Input file name
my $input_file = undef;

# Version number        XXX
my $version = "XXX";

# Usage message.
my $usage = <<END
usage: ms_print [options]

  options for the user, with defaults in [ ], are:
    -h --help             show this message
    -v --version          show version
    --<pid>               read profile data from massif.<pid>
    --massif-out-file=<file>   read profile data from <file>
    --threshold=<n>       significance threshold, in percent [$threshold]

  You must use either --<pid> or --massif-out-file exactly once
  in order that cg_annotate knows what file to read profile data from.

  ms_print is Copyright (C) 2007 Nicholas Nethercote.
  and licensed under the GNU General Public License, version 2.
  Bug reports, feedback, admiration, abuse, etc, to: njn\@valgrind.org.
                                                
END
;

# Used in various places of output.
my $fancy = '-' x 80 . "\n";

#-----------------------------------------------------------------------------
# Argument and option handling
#-----------------------------------------------------------------------------
sub process_cmd_line() 
{
    for my $arg (@ARGV) { 

        # Option handling
        if ($arg =~ /^-/) {

            # --version
            if ($arg =~ /^-v$|^--version$/) {
                die("cg_annotate-$version\n");

            # --threshold=X (tolerates a trailing '%')
            } elsif ($arg =~ /^--threshold=([\d\.]+)%?$/) {
                $threshold = $1;
                ($1 >= 0 && $1 <= 100) or die($usage);

            # --massif-out-file=<filename>
            } elsif ($arg =~ /^--massif-out-file=(.*)$/) {
                if (not defined $input_file) {
                    $input_file = $1;
                } else {
                    die("You may only specify one input file\n" .
                        "using the --<pid> and --massif-out-file options.\n");
                }

            # --<pid>
            } elsif ($arg =~ /^--(\d+)$/) {
                my $pid = $1;
                if (not defined $input_file) {
                    $input_file = "massif.$pid";
                } else {
                    die("You may only specify one input file\n" .
                        "using the --<pid> and --massif-out-file options.\n");
                }

            } else {            # -h and --help fall under this case
                die($usage);
            }
        }
    }

    # Must have chosen an input file
    if (not defined $input_file) {
        die($usage);
    }
}

#-----------------------------------------------------------------------------
# Reading of input file
#-----------------------------------------------------------------------------

# Gets the next line, stripping comments and skipping blanks.
# Returns undef at EOF.
sub get_line()
{
    while (my $line = <INPUTFILE>) {
        $line =~ s/#.*$//;          # remove comments
        if ($line !~ /^\s*$/) {
            return $line;           # return $line if non-empty
        }
    }
    return undef;       # EOF: return undef
}

sub equals_num_line($$)
{
    my ($line, $fieldname) = @_;
    (defined($line) and $line =~ s/^$fieldname=(.*)\s*$//) or
        die("Line $.: expected \"$fieldname\" line, got:\n$line\n");
    return $1;
}

sub get_equals_num_line($)
{
    my ($fieldname) = @_;
    my $line = get_line();
    return equals_num_line($line, $fieldname);
}

# Forward declaration, because it's recursive.
sub read_heap_tree($$$$);

sub read_heap_tree($$$$)
{
    # We precede this node's line with "$this_prefix.$arrow".  We precede
    # any children of this node with "$this_prefix$child_midfix$arrow".
    my ($this_prefix, $child_midfix, $arrow, $mem_total_B) = @_;
    my $line = get_line();
    (defined $line and $line =~ /^\s*n(\d+):(\d+)(.*)$/)
        or die("Line $.: expected a tree node line, got:\n$line\n");
    my $n       = $1;
    my $bytes   = $2;
    my $details = $3;
    my $perc    = 100 * $bytes / $mem_total_B;
    printf("$this_prefix$arrow%05.2f%% (${bytes}B)$details\n", $perc);
    for (my $i = 0; $i < $n; $i++) {
        my $this_prefix2 = $this_prefix . $child_midfix;
        # If child is the last sibling, the midfix is empty.
        my $child_midfix2 = ( $i+1 == $n ? "  " : "| " );
        read_heap_tree($this_prefix2, $child_midfix2, "->", $mem_total_B);
    }
    # If this node has no children, print an extra empty line.
    if (0 == $n) {
        print("$this_prefix\n");
    }
}

sub read_input_file() 
{
    open(INPUTFILE, "< $input_file") 
         || die "Cannot open $input_file for reading\n";

    print($fancy);

    # Read "desc:" lines.
    my $line;
    while ($line = get_line()) {
        if ($line =~ s/^desc:\s*//) {
            $desc .= $line;
        } else {
            last;
        }
    }
    print($desc);

    # Read "cmd:" line (Nb: will already be in $line from "desc:" loop above).
    ($line =~ /^cmd:\s*(.*)$/) or die("Line $.: missing command line\n");
    $cmd = $1;
    print("Command:          $cmd\n");

    print("Data file:        $input_file\n");

    # Read body of input file.
    $line = get_line();
    while (defined $line) {
        # XXX: equals_num_line vs get_equals_num_line is ugly
        my $snapshot_num     =     equals_num_line($line, "snapshot");
        my $time_ms          = get_equals_num_line("time_ms");
        my $mem_total_B      = get_equals_num_line("mem_total_B");
        my $mem_heap_B       = get_equals_num_line("mem_heap_B");
        my $mem_heap_admin_B = get_equals_num_line("mem_heap_admin_B");
        my $mem_stacks_B     = get_equals_num_line("mem_stacks_B");
        my $heap_tree        = get_equals_num_line("heap_tree");

        # Print snapshot header.
        printf("=================================\n");
        printf("== snapshot $snapshot_num (%s ms)\n", commify($time_ms)); 
        printf("=================================\n");
        printf("Total memory usage: %12s bytes\n", commify($mem_total_B));
        printf("Useful heap usage : %12s bytes\n", commify($mem_heap_B));
        printf("Admin  heap usage : %12s bytes\n", commify($mem_heap_admin_B));
        printf("Stacks usage      : %12s bytes\n", commify($mem_stacks_B));

        if      ($heap_tree eq "empty") {
            # do nothing
        } elsif ($heap_tree eq "...") {
            # Depth in the heap tree.
            read_heap_tree("", "", "", $mem_total_B);
        }
        $line = get_line();
    }

    close(INPUTFILE);
}

#-----------------------------------------------------------------------------
# Print options used
#-----------------------------------------------------------------------------
# XXX: unused
sub print_options ()
{
    print($fancy);
    print($desc);
    print("Command:          $cmd\n");
    print("Data file:        $input_file\n");
#    print("Events recorded:  @events\n");
#    print("Events shown:     @show_events\n");
#    print("Event sort order: @sort_events\n");
#    print("Thresholds:       @thresholds\n");
#
#    my @include_dirs2 = @include_dirs;  # copy @include_dirs
#    shift(@include_dirs2);       # remove "" entry, which is always the first
#    unshift(@include_dirs2, "") if (0 == @include_dirs2); 
#    my $include_dir = shift(@include_dirs2);
#    print("Include dirs:     $include_dir\n");
#    foreach my $include_dir (@include_dirs2) {
#        print("                  $include_dir\n");
#    }
#
#    my @user_ann_files = keys %user_ann_files;
#    unshift(@user_ann_files, "") if (0 == @user_ann_files); 
#    my $user_ann_file = shift(@user_ann_files);
#    print("User annotated:   $user_ann_file\n");
#    foreach $user_ann_file (@user_ann_files) {
#        print("                  $user_ann_file\n");
#    }
#
#    my $is_on = ($auto_annotate ? "on" : "off");
#    print("Auto-annotation:  $is_on\n");
#    print("\n");
}

#-----------------------------------------------------------------------------
# Print summary and sorted function totals
#-----------------------------------------------------------------------------
#sub mycmp ($$) 
#{
#    my ($c, $d) = @_;
#
#    # Iterate through sort events (eg. 3,2); return result if two are different
#    foreach my $i (@sort_order) {
#        my ($x, $y);
#        $x = $c->[$i];
#        $y = $d->[$i];
#        $x = -1 unless defined $x;
#        $y = -1 unless defined $y;
#
#        my $cmp = $y <=> $x;        # reverse sort
#        if (0 != $cmp) {
#            return $cmp;
#        }
#    }
#    # Exhausted events, equal
#    return 0;
#}

sub commify ($) {
    my ($val) = @_;
    1 while ($val =~ s/^(\d+)(\d{3})/$1,$2/);
    return $val;
}

# Because the counts can get very big, and we don't want to waste screen space
# and make lines too long, we compute exactly how wide each column needs to be
# by finding the widest entry for each one.
#sub compute_CC_col_widths (@) 
#{
#    my @CCs = @_;
#    my $CC_col_widths = [];
#
#    # Initialise with minimum widths (from event names)
#    foreach my $event (@events) {
#        push(@$CC_col_widths, length($event));
#    }
#    
#    # Find maximum width count for each column.  @CC_col_width positions
#    # correspond to @CC positions.
#    foreach my $CC (@CCs) {
#        foreach my $i (0 .. scalar(@$CC)-1) {
#            if (defined $CC->[$i]) {
#                # Find length, accounting for commas that will be added
#                my $length = length $CC->[$i];
#                my $clength = $length + int(($length - 1) / 3);
#                $CC_col_widths->[$i] = max($CC_col_widths->[$i], $clength); 
#            }
#        }
#    }
#    return $CC_col_widths;
#}
#
## Print the CC with each column's size dictated by $CC_col_widths.
#sub print_CC ($$) 
#{
#    my ($CC, $CC_col_widths) = @_;
#
#    foreach my $i (@show_order) {
#        my $count = (defined $CC->[$i] ? commify($CC->[$i]) : ".");
#        my $space = ' ' x ($CC_col_widths->[$i] - length($count));
#        print("$space$count ");
#    }
#}
#
#sub print_events ($)
#{
#    my ($CC_col_widths) = @_;
#
#    foreach my $i (@show_order) { 
#        my $event       = $events[$i];
#        my $event_width = length($event);
#        my $col_width   = $CC_col_widths->[$i];
#        my $space       = ' ' x ($col_width - $event_width);
#        print("$space$event ");
#    }
#}
#
## Prints summary and function totals (with separate column widths, so that
## function names aren't pushed over unnecessarily by huge summary figures).
## Also returns a hash containing all the files that are involved in getting the
## events count above the thresholds (ie. all the interesting ones).
#sub print_summary_and_fn_totals ()
#{
#    my @fn_fullnames = keys   %fn_totals;
#
#    # Work out the size of each column for printing (summary and functions
#    # separately).
#    my $summary_CC_col_widths = compute_CC_col_widths($summary_CC);
#    my      $fn_CC_col_widths = compute_CC_col_widths(values %fn_totals);
#
#    # Header and counts for summary
#    print($fancy);
#    print_events($summary_CC_col_widths);
#    print("\n");
#    print($fancy);
#    print_CC($summary_CC, $summary_CC_col_widths);
#    print(" PROGRAM TOTALS\n");
#    print("\n");
#
#    # Header for functions
#    print($fancy);
#    print_events($fn_CC_col_widths);
#    print(" file:function\n");
#    print($fancy);
#
#    # Sort function names into order dictated by --sort option.
#    @fn_fullnames = sort {
#        mycmp($fn_totals{$a}, $fn_totals{$b})
#    } @fn_fullnames;
#
#
#    # Assertion
#    (scalar @sort_order == scalar @thresholds) or 
#        die("sort_order length != thresholds length:\n",
#            "  @sort_order\n  @thresholds\n");
#
#    my $threshold_files       = {};
#    # @curr_totals has the same shape as @sort_order and @thresholds
#    my @curr_totals = ();
#    foreach my $e (@thresholds) {
#        push(@curr_totals, 0);
#    }
#
#    # Print functions, stopping when the threshold has been reached.
#    foreach my $fn_name (@fn_fullnames) {
#
#        # Stop when we've reached all the thresholds
#        my $reached_all_thresholds = 1;
#        foreach my $i (0 .. scalar @thresholds - 1) {
#            my $prop = $curr_totals[$i] * 100 / $summary_CC->[$sort_order[$i]];
#            $reached_all_thresholds &&= ($prop >= $thresholds[$i]);
#        }
#        last if $reached_all_thresholds;
#
#        # Print function results
#        my $fn_CC = $fn_totals{$fn_name};
#        print_CC($fn_CC, $fn_CC_col_widths);
#        print(" $fn_name\n");
#
#        # Update the threshold counts
#        my $filename = $fn_name;
#        $filename =~ s/:.+$//;    # remove function name
#        $threshold_files->{$filename} = 1;
#        foreach my $i (0 .. scalar @sort_order - 1) {
#            $curr_totals[$i] += $fn_CC->[$sort_order[$i]] 
#                if (defined $fn_CC->[$sort_order[$i]]);
#        }
#    }
#    print("\n");
#
#    return $threshold_files;
#}

#-----------------------------------------------------------------------------
# Annotate selected files
#-----------------------------------------------------------------------------

## Issue a warning that the source file is more recent than the input file. 
#sub warning_on_src_more_recent_than_inputfile ($)
#{
#    my $src_file = $_[0];
#
#    my $warning = <<END
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@ Source file '$src_file' is more recent than input file '$input_file'.
#@ Annotations may not be correct.
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#
#END
#;
#    print($warning);
#}
#
## If there is information about lines not in the file, issue a warning
## explaining possible causes.
#sub warning_on_nonexistent_lines ($$$)
#{
#    my ($src_more_recent_than_inputfile, $src_file, $excess_line_nums) = @_;
#    my $cause_and_solution;
#
#    if ($src_more_recent_than_inputfile) {
#        $cause_and_solution = <<END
#@@ cause:    '$src_file' has changed since information was gathered.
#@@           If so, a warning will have already been issued about this.
#@@ solution: Recompile program and rerun under "valgrind --cachesim=yes" to 
#@@           gather new information.
#END
#    # We suppress warnings about .h files
#    } elsif ($src_file =~ /\.h$/) {
#        $cause_and_solution = <<END
#@@ cause:    bug in the Valgrind's debug info reader that screws up with .h
#@@           files sometimes
#@@ solution: none, sorry
#END
#    } else {
#        $cause_and_solution = <<END
#@@ cause:    not sure, sorry
#END
#    }
#
#    my $warning = <<END
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@
#@@ Information recorded about lines past the end of '$src_file'.
#@@
#@@ Probable cause and solution:
#$cause_and_solution@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#END
#;
#    print($warning);
#}
#
#sub annotate_ann_files($)
#{
#    my ($threshold_files) = @_; 
#
#    my %all_ann_files;
#    my @unfound_auto_annotate_files;
#    my $printed_totals_CC = [];
#
#    # If auto-annotating, add interesting files (but not "???")
#    if ($auto_annotate) {
#        delete $threshold_files->{"???"};
#        %all_ann_files = (%user_ann_files, %$threshold_files) 
#    } else {
#        %all_ann_files = %user_ann_files;
#    }
#
#    # Track if we did any annotations.
#    my $did_annotations = 0;
#
#    LOOP:
#    foreach my $src_file (keys %all_ann_files) {
#
#        my $opened_file = "";
#        my $full_file_name = "";
#        foreach my $include_dir (@include_dirs) {
#            my $try_name = $include_dir . $src_file;
#            if (open(INPUTFILE, "< $try_name")) {
#                $opened_file    = $try_name;
#                $full_file_name = ($include_dir eq "" 
#                                  ? $src_file 
#                                  : "$include_dir + $src_file"); 
#                last;
#            }
#        }
#        
#        if (not $opened_file) {
#            # Failed to open the file.  If chosen on the command line, die.
#            # If arose from auto-annotation, print a little message.
#            if (defined $user_ann_files{$src_file}) {
#                die("File $src_file not opened in any of: @include_dirs\n");
#
#            } else {
#                push(@unfound_auto_annotate_files, $src_file);
#            }
#
#        } else {
#            # File header (distinguish between user- and auto-selected files).
#            print("$fancy");
#            my $ann_type = 
#                (defined $user_ann_files{$src_file} ? "User" : "Auto");
#            print("-- $ann_type-annotated source: $full_file_name\n");
#            print("$fancy");
#
#            # Get file's CCs
#            my $src_file_CCs = $all_ind_CCs{$src_file};
#            if (!defined $src_file_CCs) {
#                print("  No information has been collected for $src_file\n\n");
#                next LOOP;
#            }
#        
#            $did_annotations = 1;
#            
#            # Numeric, not lexicographic sort!
#            my @line_nums = sort {$a <=> $b} keys %$src_file_CCs;  
#
#            # If $src_file more recent than cachegrind.out, issue warning
#            my $src_more_recent_than_inputfile = 0;
#            if ((stat $opened_file)[9] > (stat $input_file)[9]) {
#                $src_more_recent_than_inputfile = 1;
#                warning_on_src_more_recent_than_inputfile($src_file);
#            }
#
#            # Work out the size of each column for printing
#            my $CC_col_widths = compute_CC_col_widths(values %$src_file_CCs);
#
#            # Events header
#            print_events($CC_col_widths);
#            print("\n\n");
#
#            # Shift out 0 if it's in the line numbers (from unknown entries,
#            # likely due to bugs in Valgrind's stabs debug info reader)
#            shift(@line_nums) if (0 == $line_nums[0]);
#
#            # Finds interesting line ranges -- all lines with a CC, and all
#            # lines within $context lines of a line with a CC.
#            my $n = @line_nums;
#            my @pairs;
#            for (my $i = 0; $i < $n; $i++) {
#                push(@pairs, $line_nums[$i] - $context);   # lower marker
#                while ($i < $n-1 && 
#                       $line_nums[$i] + 2*$context >= $line_nums[$i+1]) {
#                    $i++;
#                }
#                push(@pairs, $line_nums[$i] + $context);   # upper marker
#            }
#
#            # Annotate chosen lines, tracking total counts of lines printed
#            $pairs[0] = 1 if ($pairs[0] < 1);
#            while (@pairs) {
#                my $low  = shift @pairs;
#                my $high = shift @pairs;
#                while ($. < $low-1) {
#                    my $tmp = <INPUTFILE>;
#                    last unless (defined $tmp);     # hack to detect EOF
#                }
#                my $src_line;
#                # Print line number, unless start of file
#                print("-- line $low " . '-' x 40 . "\n") if ($low != 1);
#                while (($. < $high) && ($src_line = <INPUTFILE>)) {
#                    if (defined $line_nums[0] && $. == $line_nums[0]) {
#                        print_CC($src_file_CCs->{$.}, $CC_col_widths);
#                        add_array_a_to_b($src_file_CCs->{$.}, 
#                                         $printed_totals_CC);
#                        shift(@line_nums);
#
#                    } else {
#                        print_CC( [], $CC_col_widths);
#                    }
#
#                    print(" $src_line");
#                }
#                # Print line number, unless EOF
#                if ($src_line) {
#                    print("-- line $high " . '-' x 40 . "\n");
#                } else {
#                    last;
#                }
#            }
#
#            # If there was info on lines past the end of the file...
#            if (@line_nums) {
#                foreach my $line_num (@line_nums) {
#                    print_CC($src_file_CCs->{$line_num}, $CC_col_widths);
#                    print(" <bogus line $line_num>\n");
#                }
#                print("\n");
#                warning_on_nonexistent_lines($src_more_recent_than_inputfile,
#                                             $src_file, \@line_nums);
#            }
#            print("\n");
#
#            # Print summary of counts attributed to file but not to any
#            # particular line (due to incomplete debug info).
#            if ($src_file_CCs->{0}) {
#                print_CC($src_file_CCs->{0}, $CC_col_widths);
#                print(" <counts for unidentified lines in $src_file>\n\n");
#            }
#            
#            close(INPUTFILE);
#        }
#    }
#
#    # Print list of unfound auto-annotate selected files.
#    if (@unfound_auto_annotate_files) {
#        print("$fancy");
#        print("The following files chosen for auto-annotation could not be found:\n");
#        print($fancy);
#        foreach my $f (@unfound_auto_annotate_files) {
#            print("  $f\n");
#        }
#        print("\n");
#    }
#
#    # If we did any annotating, print what proportion of events were covered by
#    # annotated lines above.
#    if ($did_annotations) {
#        my $percent_printed_CC;
#        foreach (my $i = 0; $i < @$summary_CC; $i++) {
#            $percent_printed_CC->[$i] = 
#                sprintf("%.0f", 
#                        $printed_totals_CC->[$i] / $summary_CC->[$i] * 100);
#        }
#        my $pp_CC_col_widths = compute_CC_col_widths($percent_printed_CC);
#        print($fancy);
#        print_events($pp_CC_col_widths);
#        print("\n");
#        print($fancy);
#        print_CC($percent_printed_CC, $pp_CC_col_widths);
#        print(" percentage of events annotated\n\n");
#    }
#}

#----------------------------------------------------------------------------
# "main()"
#----------------------------------------------------------------------------
process_cmd_line();
read_input_file();
#print_options();
#my $threshold_files = print_summary_and_fn_totals();
#annotate_ann_files($threshold_files);

##--------------------------------------------------------------------##
##--- end                                           cg_annotate.in ---##
##--------------------------------------------------------------------##


