#! /usr/bin/perl

##--------------------------------------------------------------------##
##--- Massif's results printer                         ms_print.in ---##
##--------------------------------------------------------------------##

#  This file is part of Massif, a Valgrind tool for profiling memory
#  usage of programs.
#
#  Copyright (C) 2007-2007 Nicholas Nethercote
#     njn@valgrind.org
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License as
#  published by the Free Software Foundation; either version 2 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
#  02111-1307, USA.
#
#  The GNU General Public License is contained in the file COPYING.

use warnings;
use strict;

# XXX:need to put threshold in the stats at the top of the output

# XXX:
# - move graph printing stuff into a separate subroutine
# - implement --threshold 
# - merge read_input_file[12]

#----------------------------------------------------------------------------
# Discussion of the graph.
#----------------------------------------------------------------------------
# The summary output includes a graph like this.
#  
#---------------------------------------------------------------------------
# 100M|B                .      :A
#     |               .:::   :::#      
#     |              :::::. c:::#:     
#     |             b:::::: |:::#::    
#     |            :|:::::::|:::#::    
#  75M|            :|:::::::|:::#:::   
#     |           ::|:::::::|:::#:::   
#     |           ::|:::::::|:::#:::d  
#     |           ::|:::::::|:::#:::|: 
#     |          .::|:::::::|:::#:::|::
#  50M|          :::|:::::::|:::#:::|:::                      
#     |         ::::|:::::::|:::#:::|:::::                        :::.
#     |        :::::|:::::::|:::#:::|::::::                    g::::::::
#     |       a:::::|:::::::|:::#:::|:::::::e:               ::|::::::::::h
#     |       |:::::|:::::::|:::#:::|:::::::|::.        :: .:::|::::::::::|::
#  25M|       |:::::|:::::::|:::#:::|:::::::|::::      f:::::::|::::::::::|::
#     |      :|:::::|:::::::|:::#:::|:::::::|::::.  .::|:::::::|::::::::::|::
#     |    .::|:::::|:::::::|:::#:::|:::::::|::::::::::|:::::::|::::::::::|::
#     |  .::::|:::::|:::::::|:::#:::|:::::::|::::::::::|:::::::|::::::::::|::
#     |:::::::|:::::|:::::::|:::#:::|:::::::|::::::::::|:::::::|::::::::::|::
#   0M+----------------------------------------------------------------------t
#     012                                                               
#
#      Temporary snapshots:
#       a: periodic snapshot, total size: 33,000,000 bytes
#       b: periodic snapshot, total size: 82,000,000 bytes
#       c: periodic snapshot, total size: 90,000,000 bytes
#       d: periodic snapshot, total size: 64,000,000 bytes
#       e: periodic snapshot, total size: 34,000,000 bytes
#       f: periodic snapshot, total size: 24,000,000 bytes
#       g: periodic snapshot, total size: 39,000,000 bytes
#       h: periodic snapshot, total size: 33,000,000 bytes
#
#      Permanent snapshots:
#       A: peak snapshot, total size: 100,000,000 bytes
#---------------------------------------------------------------------------
#
# Explanation of the y-axis:
# - Top of the x-axis box represents 0.
#
#    4M^|   .:     This row has base=2M, half-threshold=3M, full-threshold=4M
#    2M^| .:::     This row has base=0M, half-threshold=1M, full-threshold=2M
#    0M +-----        
#        abcde        
#                   
# - A '.' is only shown in a row if we've reached its half-threshold
# - A ':' is only shown in a row if we've reached its full-threshold
# - So: a is in range 0 -- 0.99 
#       b is in range 1 -- 1.99 
#       c is in range 2 -- 2.99
#       d is in range 3 -- 3.99
#       e is in range 4 -- 4.99
#
# Explanation of x-axis:
# - Assume each column represents one second
# - First usable column has range 0..0.99s
# - Second usable column has range 1..1.99s
# - etc.



#----------------------------------------------------------------------------
# Global variables, main data structures
#----------------------------------------------------------------------------

# Command line of profiled program.
my $cmd;

# Threshold dictating what percentage an entry must represent for us to
# bother showing it.
my $threshold = 1.0;

# Input file name
my $input_file = undef;

# Version number
my $version = "XXX";

# Usage message.
my $usage = <<END
usage: ms_print [options]

  options for the user, with defaults in [ ], are:
    -h --help             show this message
    -v --version          show version
    --<pid>               read profile data from massif.<pid>
    --massif-out-file=<file>   read profile data from <file>
    --threshold=<n>       significance threshold, in percent [$threshold]

  You must use either --<pid> or --massif-out-file exactly once
  in order that ms_print knows what file to read profile data from.

  ms_print is Copyright (C) 2007-2007 Nicholas Nethercote.
  and licensed under the GNU General Public License, version 2.
  Bug reports, feedback, admiration, abuse, etc, to: njn\@valgrind.org.
                                                
END
;

# Used in various places of output.
my $fancy = '-' x 80 . "\n";

#-----------------------------------------------------------------------------
# Argument and option handling
#-----------------------------------------------------------------------------
sub process_cmd_line() 
{
    for my $arg (@ARGV) { 

        # Option handling
        if ($arg =~ /^-/) {

            # --version
            if ($arg =~ /^-v$|^--version$/) {
                die("ms_print-$version\n");

            # --threshold=X (tolerates a trailing '%')
            } elsif ($arg =~ /^--threshold=([\d\.]+)%?$/) {
                $threshold = $1;
                ($1 >= 0 && $1 <= 100) or die($usage);

            # --massif-out-file=<filename>
            } elsif ($arg =~ /^--massif-out-file=(.*)$/) {
                if (not defined $input_file) {
                    $input_file = $1;
                } else {
                    die("You may only specify one input file\n" .
                        "using the --<pid> and --massif-out-file options.\n");
                }

            # --<pid>
            } elsif ($arg =~ /^--(\d+)$/) {
                my $pid = $1;
                if (not defined $input_file) {
                    $input_file = "massif.$pid";
                } else {
                    die("You may only specify one input file\n" .
                        "using the --<pid> and --massif-out-file options.\n");
                }

            } else {            # -h and --help fall under this case
                die($usage);
            }
        }
    }

    # Must have chosen an input file
    if (not defined $input_file) {
        die($usage);
    }
}

#-----------------------------------------------------------------------------
# Reading the input file: auxiliary functions
#-----------------------------------------------------------------------------

# Gets the next line, stripping comments and skipping blanks.
# Returns undef at EOF.
sub get_line()
{
    while (my $line = <INPUTFILE>) {
        $line =~ s/#.*$//;          # remove comments
        $line =~ s/==\d+==.*$//;    # remove Valgrind output lines   XXX
        if ($line !~ /^\s*$/) {
            return $line;           # return $line if non-empty
        }
    }
    return undef;       # EOF: return undef
}

sub equals_num_line($$)
{
    my ($line, $fieldname) = @_;
    (defined($line) and $line =~ s/^$fieldname=(.*)\s*$//) or
        die("Line $.: expected \"$fieldname\" line, got:\n$line\n");
    return $1;
}

sub get_equals_num_line($)
{
    my ($fieldname) = @_;
    my $line = get_line();
    return equals_num_line($line, $fieldname);
}

sub is_significant_XPt($$)
{
    my ($xpt_szB, $total_szB) = @_;
    ($xpt_szB <= $total_szB) or die;
    return ( $xpt_szB * 100 / $total_szB >= $threshold ? 1 : 0 );
}

# Forward declaration, because it's recursive.
sub read_heap_tree($$$$$);

# Return pair:  if the tree was significant, both are zero.  If it was
# insignificant, the first element is 1 and the second is the number of
# bytes.
sub read_heap_tree($$$$$)
{
    # Read the line and determine if it is significant.
    my ($print, $this_prefix, $child_midfix, $arrow, $mem_total_B) = @_;
    my $line = get_line();
    (defined $line and $line =~ /^\s*n(\d+):\s*(\d+)(.*)$/)
        or die("Line $.: expected a tree node line, got:\n$line\n");
    my $n_children = $1;
    my $bytes      = $2;
    my $details    = $3;
    my $perc       = 100 * $bytes / $mem_total_B;
    my $is_significant = is_significant_XPt($bytes, $mem_total_B);

    # We precede this node's line with "$this_prefix.$arrow".  We precede
    # any children of this node with "$this_prefix$child_midfix$arrow".
    if ($print && $is_significant) {
        printf("$this_prefix$arrow%05.2f%% $is_significant(${bytes}B)$details\n", $perc);
    }

    # Now read all the children.
    my $n_insig_children = 0;
    my $total_insig_children_szB = 0;
    my $this_prefix2 = $this_prefix . $child_midfix;
    for (my $i = 0; $i < $n_children; $i++) {
        # If child is the last sibling, the midfix is empty.
        my $child_midfix2 = ( $i+1 == $n_children ? "  " : "| " );
        my ($is_child_insignificant, $child_insig_bytes) =
            read_heap_tree($print, $this_prefix2, $child_midfix2, "->",
                $mem_total_B);
        $n_insig_children += $is_child_insignificant;
        $total_insig_children_szB += $child_insig_bytes;
    }

    if ($is_significant) {
        # If this was significant but any children were insignificant, print
        # an "insignificant" line for them.
        if ($print && $n_insig_children > 0) {
            $perc = 100 * $total_insig_children_szB / $mem_total_B;
            printf("$this_prefix2->%05.2f%% (${total_insig_children_szB}B) ... $n_insig_children insig...\n",
                $perc);
            print("$this_prefix2\n");
        }

        # If this node has no children, print an extra empty line.
        if ($print && 0 == $n_children) {
            print("$this_prefix\n");
        }
        return (0, 0);

    } else {
        return (1, $bytes);
    }
}

#-----------------------------------------------------------------------------
# Reading the input file: pass 1
#-----------------------------------------------------------------------------

# This pass is just for printing the graph.  It just collects the snapshot
# times and total sizes from the file and then prints the graph.
#
# XXX: should probably combine read_input_file[12] into a single function
# with some conditionals in it.
sub read_input_file1() 
{
    my $desc = "";              # Concatenated description lines.
    my @snapshot_nums = ();
    my @time_mss      = ();
    my @mem_total_Bs  = ();
    my @is_detaileds  = ();
    my $peak_mem_total_szB = 0;
    
    open(INPUTFILE, "< $input_file") 
         || die "Cannot open $input_file for reading\n";

    # Read "desc:" lines.
    my $line;
    while ($line = get_line()) {
        if ($line =~ s/^desc:\s*//) {
            $desc .= $line;
        } else {
            last;
        }
    }

    # Read "cmd:" line (Nb: will already be in $line from "desc:" loop above).
    ($line =~ /^cmd:\s*(.*)$/) or die("Line $.: missing command line\n");
    $cmd = $1;

    # Read body of input file.
    $line = get_line();
    while (defined $line) {
        # XXX: equals_num_line vs get_equals_num_line is ugly
        my $snapshot_num     =     equals_num_line($line, "snapshot");
        my $time_ms          = get_equals_num_line("time_ms");
        my $mem_total_B      = get_equals_num_line("mem_total_B");
        my $mem_heap_B       = get_equals_num_line("mem_heap_B");
        my $mem_heap_admin_B = get_equals_num_line("mem_heap_admin_B");
        my $mem_stacks_B     = get_equals_num_line("mem_stacks_B");
        my $heap_tree        = get_equals_num_line("heap_tree");

        # Skip over the heap_tree
        if      ($heap_tree eq "empty") {
            # do nothing
        } elsif ($heap_tree eq "...") {
            # Depth in the heap tree.  '0' means the tree should not be printed.
            read_heap_tree(0, "", "", "", $mem_total_B);
        } else {
            die("Line $.: expected 'empty' or '...' after 'heap_tree='\n");
        }

        # Remember the pertinent information
        push(@snapshot_nums, $snapshot_num);
        push(@time_mss,      $time_ms);
        push(@mem_total_Bs,  $mem_total_B);
        push(@is_detaileds,  ( $heap_tree eq "empty" ? 0 : 1 ));
        $peak_mem_total_szB = $mem_total_B
            if $mem_total_B > $peak_mem_total_szB;

        $line = get_line();
    }

    close(INPUTFILE);

    #-------------------------------------------------------------------------
    # Print header
    #-------------------------------------------------------------------------
    print($fancy);
    print("Command:          $cmd\n");
    print("Data file:        $input_file\n");
    print($desc);
    print("\n");

    #-------------------------------------------------------------------------
    # Print graph
    #-------------------------------------------------------------------------
    # The ASCII graph.
    # Row    0 ([0..GRAPH_X][0]) is the x-axis.
    # Column 0 ([0][0..GRAPH_Y]) is the y-axis.
    # The rest ([1][1]..[GRAPH_X][GRAPH_Y]) is the usable graph area.
    my $GRAPH_X = 72;       # Make these command-line options
    my $GRAPH_Y = 20;
    my @graph;
    my $x;
    my $y;

    # We increment end_ms_time by 1 so that the last snapshot occurs just
    # before it, and doesn't spill over into the final column.
    my $n_snapshots = scalar(@snapshot_nums);
    ($n_snapshots > 0) or die;
    my $end_time_ms = $time_mss[$n_snapshots-1] + 1;
    ($end_time_ms > 0) or die;

    # Setup graph[][].
    $graph[0][0] = '+';                                       # axes join point
    for ($x = 1; $x <= $GRAPH_X; $x++) { $graph[$x][0] = '-'; }    # x-axis
    for ($y = 1; $y <= $GRAPH_Y; $y++) { $graph[0][$y] = '|'; }    # y-axis
    for ($x = 1; $x <= $GRAPH_X; $x++) {                         # usable area
       for ($y = 1; $y <= $GRAPH_Y; $y++) {
          $graph[$x][$y] = ' ';
       }
    }

    # Write snapshot bars into graph[][].
    # XXX: many detailed snapshot bars are being overwritten by non-detailed
    #      bars
    for (my $i = 0; $i < $n_snapshots; $i++) {
 
        # Work out how many bytes each row represents.
        my $per_row_full_thresh_szB = $peak_mem_total_szB / $GRAPH_Y;
        my $per_row_half_thresh_szB = $per_row_full_thresh_szB / 2;
 
        # Work out which column this snapshot belongs to.
        my $x_pos_frac = ($time_mss[$i] / $end_time_ms) * $GRAPH_X;
        $x = int($x_pos_frac) + 1;    # +1 due to y-axis
 
        # Grow this snapshot bar from bottom to top.
        for ($y = 1; $y <= $GRAPH_Y; $y++) {
            my $this_row_full_thresh_szB = $y * $per_row_full_thresh_szB;
            my $this_row_half_thresh_szB =
                $this_row_full_thresh_szB - $per_row_half_thresh_szB;
 
            $graph[$x][$y] = ' ';
            if ($mem_total_Bs[$i] >= $this_row_half_thresh_szB) {
                $graph[$x][$y] = '.';
            }
            if ($mem_total_Bs[$i] >= $this_row_full_thresh_szB) {
                $graph[$x][$y] = ( $is_detaileds[$i] ? '|' : ':' );
            }
        }
        # If it's detailed, mark the x-axis
        if ($is_detaileds[$i])  {
           $graph[$x][0] = '|';
        }
    }

    # Work out the units for the $y-axis.
    my $orders_of_magnitude = 0;
    my $unit;
    my $peak_mem_total_szBscaled = $peak_mem_total_szB;
    while ($peak_mem_total_szBscaled > 1000) {
        $orders_of_magnitude++;
        $peak_mem_total_szBscaled /= 1000;
    }
    if    (0 == $orders_of_magnitude) { $unit = ' '; } 
    elsif (1 == $orders_of_magnitude) { $unit = 'k'; } 
    elsif (2 == $orders_of_magnitude) { $unit = 'M'; } 
    elsif (3 == $orders_of_magnitude) { $unit = 'G'; } 
    elsif (4 == $orders_of_magnitude) { $unit = 'T'; } 
    else { die("unknown order of magnitude: $orders_of_magnitude\n"); }

    # Print graph[][].
    for ($y = $GRAPH_Y; $y >= 0; $y--) {
        # Row prefix (ie. x-axis label)
        if ($GRAPH_Y == $y) {            # top point
           if ($peak_mem_total_szBscaled < 10) {
                printf("%3.1f%s", $peak_mem_total_szBscaled, $unit);
            } else {
                printf("%3d%s", $peak_mem_total_szBscaled, $unit);
            }
        } elsif (0 == $y) {              # bottom point
            print("  0 ");
        } else {                         # anywhere else
            print("    ");
        }
          
        # Axis and data for the row.
        for ($x = 0; $x <= $GRAPH_X; $x++) {
            printf("%s", $graph[$x][$y]);
        }
        print("\n");
    }

    #-------------------------------------------------------------------------
    # Print graph legend
    #-------------------------------------------------------------------------
    print("\n");
    for (my $i = 0; $i < $n_snapshots; $i++) {
        # XXX adjust the column widths dynamically
        printf("  snapshot %3d: t = %12s ms, size = %12s bytes\n",
            $snapshot_nums[$i], commify($time_mss[$i]),
            commify($mem_total_Bs[$i]));
    }
    print("\n");
}

#-----------------------------------------------------------------------------
# Reading the input file: pass 2
#-----------------------------------------------------------------------------

# This pass is for printing the snapshots.  It prints them as it reads in
# the file (as opposed to reading it all in and then dumping the output at
# the end).
sub read_input_file2() 
{
    open(INPUTFILE, "< $input_file") 
         || die "Cannot open $input_file for reading\n";

    # Read "desc:" lines.
    my $line;
    while ($line = get_line()) {
        if ($line !~ s/^desc:\s*//) {
            last;
        }
    }

    # Read "cmd:" line (Nb: will already be in $line from "desc:" loop above).
    ($line =~ /^cmd:\s*(.*)$/) or die("Line $.: missing command line\n");

    # Read body of input file.
    $line = get_line();
    while (defined $line) {
        # XXX: equals_num_line vs get_equals_num_line is ugly
        my $snapshot_num     =     equals_num_line($line, "snapshot");
        my $time_ms          = get_equals_num_line("time_ms");
        my $mem_total_B      = get_equals_num_line("mem_total_B");
        my $mem_heap_B       = get_equals_num_line("mem_heap_B");
        my $mem_heap_admin_B = get_equals_num_line("mem_heap_admin_B");
        my $mem_stacks_B     = get_equals_num_line("mem_stacks_B");
        my $heap_tree        = get_equals_num_line("heap_tree");

        # Print snapshot header.
        printf("=================================\n");
        printf("== snapshot $snapshot_num (%s ms)\n", commify($time_ms)); 
        printf("=================================\n");
        printf("Total memory usage: %12s bytes\n", commify($mem_total_B));
        printf("Useful heap usage : %12s bytes\n", commify($mem_heap_B));
        printf("Admin  heap usage : %12s bytes\n", commify($mem_heap_admin_B));
        printf("Stacks usage      : %12s bytes\n", commify($mem_stacks_B));

        if      ($heap_tree eq "empty") {
            # do nothing
        } elsif ($heap_tree eq "...") {
            # Depth in the heap tree.  '1' means the tree should be printed.
            read_heap_tree(1, "", "", "", $mem_total_B);
        } else {
            die("Line $.: expected 'empty' or '...' after 'heap_tree='\n");
        }
        $line = get_line();
    }

    close(INPUTFILE);
}

#-----------------------------------------------------------------------------
# Misc functions
#-----------------------------------------------------------------------------
sub commify ($) {
    my ($val) = @_;
    1 while ($val =~ s/^(\d+)(\d{3})/$1,$2/);
    return $val;
}


#----------------------------------------------------------------------------
# "main()"
#----------------------------------------------------------------------------
process_cmd_line();
read_input_file1();
read_input_file2();
#print_options();
#my $threshold_files = print_summary_and_fn_totals();
#annotate_ann_files($threshold_files);

##--------------------------------------------------------------------##
##--- end                                              ms_print.in ---##
##--------------------------------------------------------------------##


